(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[2663],{4024:function(e,n,t){"use strict";let r;t.d(n,{Z:function(){return F}});var s=t(42),a=t.n(s),o=t(7406),l=t(7667),i=t.n(l),u=t(8554);let c=()=>(0,u.Z)()&&window.document.documentElement,m=()=>{if(!c())return!1;if(void 0!==r)return r;let e=document.createElement("div");return e.style.display="flex",e.style.flexDirection="column",e.style.rowGap="1px",e.appendChild(document.createElement("div")),e.appendChild(document.createElement("div")),document.body.appendChild(e),r=1===e.scrollHeight,document.body.removeChild(e),r};var d=()=>{let[e,n]=l.useState(!1);return l.useEffect(()=>{n(m())},[]),e},p=t(6775),f=t(1630);let v=i().createContext({latestIndex:0,horizontalSize:0,verticalSize:0,supportFlexGap:!1}),x=v.Provider;function g(e){let{className:n,direction:t,index:r,marginDirection:s,children:a,split:o,wrap:i,style:u}=e,{horizontalSize:c,verticalSize:m,latestIndex:d,supportFlexGap:p}=l.useContext(v),f={};return(!p&&("vertical"===t?r<d&&(f={marginBottom:c/(o?2:1)}):f=Object.assign(Object.assign({},r<d&&{[s]:c/(o?2:1)}),i&&{paddingBottom:m})),null==a)?null:l.createElement(l.Fragment,null,l.createElement("div",{className:n,style:Object.assign(Object.assign({},f),u)},a),r<d&&o&&l.createElement("span",{className:`${n}-split`,style:f},o))}var h=t(1977),b=function(e,n){var t={};for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&0>n.indexOf(r)&&(t[r]=e[r]);if(null!=e&&"function"==typeof Object.getOwnPropertySymbols)for(var s=0,r=Object.getOwnPropertySymbols(e);s<r.length;s++)0>n.indexOf(r[s])&&Object.prototype.propertyIsEnumerable.call(e,r[s])&&(t[r[s]]=e[r[s]]);return t};let y={small:8,middle:16,large:24},C=l.forwardRef((e,n)=>{var t,r;let{getPrefixCls:s,space:i,direction:u}=l.useContext(p.E_),{size:c=(null==i?void 0:i.size)||"small",align:m,className:f,rootClassName:v,children:C,direction:F="horizontal",prefixCls:V,split:j,style:S,wrap:k=!1,classNames:N,styles:O}=e,E=b(e,["size","align","className","rootClassName","children","direction","prefixCls","split","style","wrap","classNames","styles"]),I=d(),[R,w]=l.useMemo(()=>(Array.isArray(c)?c:[c,c]).map(e=>"string"==typeof e?y[e]:e||0),[c]),M=(0,o.Z)(C,{keepEmpty:!0}),P=void 0===m&&"horizontal"===F?"center":m,$=s("space",V),[_,J]=(0,h.Z)($),T=a()($,J,`${$}-${F}`,{[`${$}-rtl`]:"rtl"===u,[`${$}-align-${P}`]:P},null!=f?f:null==i?void 0:i.className,v),Z=a()(`${$}-item`,null!==(t=null==N?void 0:N.item)&&void 0!==t?t:null===(r=null==i?void 0:i.classNames)||void 0===r?void 0:r.item),z="rtl"===u?"marginLeft":"marginRight",W=0,A=M.map((e,n)=>{var t,r;null!=e&&(W=n);let s=e&&e.key||`${Z}-${n}`;return l.createElement(g,{className:Z,key:s,direction:F,index:n,marginDirection:z,split:j,wrap:k,style:null!==(t=null==O?void 0:O.item)&&void 0!==t?t:null===(r=null==i?void 0:i.styles)||void 0===r?void 0:r.item},e)}),G=l.useMemo(()=>({horizontalSize:R,verticalSize:w,latestIndex:W,supportFlexGap:I}),[R,w,W,I]);if(0===M.length)return null;let q={};return k&&(q.flexWrap="wrap",I||(q.marginBottom=-w)),I&&(q.columnGap=R,q.rowGap=w),_(l.createElement("div",Object.assign({ref:n,className:T,style:Object.assign(Object.assign(Object.assign({},q),null==i?void 0:i.style),S)},E),l.createElement(x,{value:G},A)))});C.Compact=f.ZP;var F=C},1841:function(e,n,t){(window.__NEXT_P=window.__NEXT_P||[]).push(["/article/react/form",function(){return t(8897)}])},8897:function(e,n,t){"use strict";t.r(n),t.d(n,{__N_SSG:function(){return f},default:function(){return F},description:function(){return g},frontMatter:function(){return v},tag:function(){return h},title:function(){return x},updated:function(){return b}});var r=t(4246),s=t(1670),a=t(7667),o=t(2374),l=t(5360),i=t(7513),u=t(4024),c=t(8062),m=o.l0.Item,d=function(){var e=(0,a.useRef)(),n=(0,a.useCallback)(function(){var n;null===(n=e.current)||void 0===n||n.validate().subscribe(function(e){console.log(e)})},[]),t=(0,a.useCallback)(function(e){console.log(e)},[]);return(0,r.jsxs)(o.l0,{ref:e,onChange:t,children:[(0,r.jsx)(m,{name:"username",defaultValue:"default",rules:[{required:!0,message:"必填项"},function(e){return/^\d+$/.test(e)?null:"只能输入数字"}],children:(0,r.jsx)("input",{})}),(0,r.jsx)(m,{name:"email",rules:[function(e){return(0,l._v)(2e3).then(function(){return/^[a-z]+$/i.test(e)?null:"只能输入英文字母"})},function(e){return(0,i.timer)(1e3).pipe((0,i.map)(function(){return e.length>10?"最大长度为10":null}))}],children:(0,r.jsx)("input",{})}),(0,r.jsx)("p",{children:(0,r.jsxs)(u.Z,{children:[(0,r.jsx)(c.ZP,{onClick:n,children:"提交"}),(0,r.jsx)(c.ZP,{onClick:function(){var n;return null===(n=e.current)||void 0===n?void 0:n.reset()},children:"重置"}),(0,r.jsx)(c.ZP,{onClick:function(){var n;return null===(n=e.current)||void 0===n?void 0:n.clearValidity()},children:"清除错误验证"})]})})]})},p=t(5685),f=!0,v={title:"Form 组件",description:"基于react、rxjs的表单校验",tag:["react","form","rxjs","web前端"],updated:"2023-02-22T07:57:53.000Z"},x="Form 组件",g="基于react、rxjs的表单校验",h=["react","form","rxjs","web前端"],b="2023-02-22T07:57:53.000Z",y=function(e){return(0,r.jsx)(p.s,e)};function C(e){var n=Object.assign({pre:"pre",code:"code"},(0,s.ah)(),e.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(d,{}),"\n",(0,r.jsxs)("details",{children:[(0,r.jsx)("summary",{children:"Form.tsx"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"import {\n  useMemo, useState, ReactNode, useRef, forwardRef, ForwardRefExoticComponent,\n  PropsWithoutRef, RefAttributes, useImperativeHandle, useCallback, FormEvent, CSSProperties,\n} from 'react';\nimport { Field } from './Field';\nimport { FormContext, FormContextInterface, FormValuesContext, FormValuesMap, FormValues } from './Context';\nimport type { Observable } from 'rxjs';\nimport { concatMap, forkJoin, of, throwError } from 'rxjs';\nimport { Status } from './interface';\nimport { trailed, combineClass } from '@shared/utils';\nimport { FormItem } from './Item';\n\nexport interface FormInstance<T=any> {\n  setItem: (name: string, value: any) => void;\n  reset: (...fields: string[]) => void;\n  clearValidity: (...fields: string[]) => void;\n  validate: (...fields: string[]) => Observable<T>;\n  readonly values: FormValuesMap;\n  toJSON: FormContextInterface['toJSON'];\n}\nexport interface FormProps {\n  className?: string;\n  style?: CSSProperties;\n  children?: ReactNode;\n  onChange?: (values: FormValues) => void;\n  onSubmit?: (instance: FormInstance) => void;\n}\ninterface FormComponent extends ForwardRefExoticComponent<PropsWithoutRef<FormProps> & RefAttributes<FormInstance | undefined>> {\n  Field: typeof Field;\n  Item: typeof FormItem;\n}\nconst Form = forwardRef<FormInstance, FormProps>((props, ref) => {\n\n  const { children, onChange, onSubmit, className, style } = props;\n\n  const [formValues, setFormValues] = useState<FormValuesMap>(new Map());\n  const formValuesRef = useRef(formValues);\n\n  const onChangeRef = useRef(onChange);\n  onChangeRef.current = onChange;\n\n  const context = useMemo<FormContextInterface>(() => {\n    let formValues: FormValuesMap = formValuesRef.current;\n    const toJSON = () => {\n      return Array.from(formValues.entries()).reduce((prev, currentValue) => {\n        const [key, val] = currentValue;\n        Object.assign(prev, { [key]: val });\n        return prev;\n      }, {} as FormValues);\n    };\n    return {\n      get values() {\n        return formValues;\n      },\n      toJSON,\n      setItem: trailed((callback) => {\n        return (name, value, options) =>  {\n          const emit = options?.emit ?? false;\n          const remove = options?.remove ?? false;\n          formValues = new Map(formValues.entries());\n          if (remove) {\n            formValues.delete(name);\n          } else {\n            formValues.set(name, value);\n          }\n          setFormValues(formValues);\n          if (emit) callback(() => onChangeRef.current?.(toJSON()));\n        };\n      }),\n      reductions: new Map(),\n      invalidations: new Map(),\n      validators: new Map(),\n      status: new Map(),\n    };\n  }, []);\n\n  const reset: FormInstance['reset'] = useCallback((...fields) => {\n    if (fields.length) {\n      fields.forEach(key => context.reductions.get(key)?.());\n    } else {\n      context.reductions.forEach(v => v());\n    }\n  }, [context]);\n\n  const validate: FormInstance['validate'] = useCallback((...fields) => {\n    let values = context.toJSON();\n    let obs: Observable<Status>[];\n    if (fields.length) {\n      obs = fields.map(key => context.validators.get(key)).filter(Boolean).map(v => v!());\n      values = fields.reduce((previousValue, key) => Object.assign(previousValue, { [key]: values[key] }), {} as FormValues);\n    } else {\n      obs = Array.from(context.validators.values()).map(v => v());\n    }\n    return forkJoin(obs).pipe(\n      concatMap(results => {\n        if (results.every(v => v.state === 'valid')) {\n          return of(values);\n        }\n        return throwError(() => results.filter(v => v.state === 'invalid'));\n      }),\n    );\n  }, [context]);\n\n  const setItem: FormInstance['setItem'] = useCallback((...args) => {\n    return context.setItem(...args);\n  }, [context]);\n\n  const clearValidity: FormInstance['clearValidity'] = useCallback((...args) => {\n    if (args.length) {\n      args.forEach(name => context.invalidations.get(name)?.());\n    } else {\n      context.invalidations.forEach(v => v());\n    }\n  }, [context]);\n  \n  const instance: FormInstance = useMemo(() => {\n    return { setItem, reset, validate, clearValidity, values: formValues, toJSON: context.toJSON };\n  }, [formValues, reset, setItem, validate, context, clearValidity]);\n\n  const handleSubmit = useCallback((e: FormEvent) => {\n    e.preventDefault();\n    onSubmit?.(instance);\n  }, [instance, onSubmit]);\n\n  useImperativeHandle(ref, () => {\n    return instance;\n  });\n\n  return (\n    <form onSubmit={handleSubmit} className={combineClass(className)} style={style}>\n      <FormValuesContext.Provider value={formValues}>\n        <FormContext.Provider value={context}>{ children }</FormContext.Provider>\n      </FormValuesContext.Provider>\n    </form>\n  );\n}) as FormComponent;\n\nForm.displayName = 'Form';\nForm.Field = Field;\nForm.Item = FormItem;\n\nexport { Form };\n"})})]}),"\n",(0,r.jsxs)("details",{children:[(0,r.jsx)("summary",{children:"Field.tsx"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"import {\n  cloneElement, FunctionComponent, ReactElement,\n  useCallback, useContext, useEffect, useMemo, useRef,\n} from 'react';\nimport { FormContext, FormValuesContext } from './Context';\nimport { Rule, Status } from './interface';\nimport {\n  concat, concatMap, from, isObservable, of, take,\n  skipWhile, switchMap, takeLast, tap, throwError, skip,\n} from 'rxjs';\nimport type { Observable } from 'rxjs';\nimport { useStore } from '@shared/stores';\nimport { useSubject } from '@shared/hooks/observable';\n\nfunction restore() {\n  //\n}\nexport interface FieldProps {\n  name: string;\n  children: ReactElement;\n  defaultValue?: any;\n  rules?: Rule[];\n  onChange?: (e: any) => void;\n  onStatusChange?: (status: Status) => void;\n}\ninterface FieldComponent extends FunctionComponent<FieldProps> {}\nconst Field: FieldComponent = (props) => {\n  const { children, name, defaultValue, rules = [], onStatusChange, onChange: fieldChange } = props;\n  const context = useContext(FormContext);\n  const values = useContext(FormValuesContext);\n\n  const refs = useRef({ context, defaultValue, rules, name });\n  refs.current.context = context;\n  refs.current.rules = rules;\n\n  const [status, store] = useStore<Status>(() => ({ state: 'initial', name }));\n\n  const nullVal = useMemo(() => {\n    if (children.type === 'input') {\n      return '';\n    }\n    return undefined;\n  }, [children]);\n  \n  const value = useMemo(() => {\n    return values?.get(name) ?? nullVal;\n  }, [name, nullVal, values]);\n\n  const status$ = useSubject<any>(action => action.pipe(\n    tap(() => store.set(Object.assign({}, store.state, { state: 'pending', name }))),\n    switchMap(value => {\n      if (value === restore) {\n        store.set({ state: 'initial', name });\n        return of(null).pipe(skip(1));\n      }\n      return validate(refs.current.rules, value);\n    }),\n    tap(() => store.set({ state: 'valid', name })),\n    store.capture(err => ({ state: 'invalid', name, message: err })),\n  ), [name, store]);\n\n  const onChange = useCallback((e: any) => {\n    const val = toFormValue(e);\n    status$?.next(val);\n    context?.setItem(name, val, { emit: true });\n    fieldChange?.(val);\n  }, [fieldChange, context, name, status$]);\n  \n  const clearValidity = useCallback(() => {\n    status$?.next(restore);\n  }, [status$]);\n\n  const reset = useCallback(() => {\n    const { context, defaultValue, name } = refs.current;\n    const value = context?.values.get(name) ?? nullVal;\n    const next = toFormValue(defaultValue) ?? nullVal;\n    clearValidity();\n    if (value !== next) {\n      context?.setItem(name, next, { emit: true });\n    }\n  }, [clearValidity, nullVal]);\n  \n  const validateField = useCallback(() => {\n    status$?.next(value); // The status will be updated to pending synchronously\n    return store.state$.pipe(\n      skipWhile(v => v.state === 'pending'),\n      take(1),\n    );\n  }, [status$, value, store]);\n  \n  useEffect(() => {\n    context?.validators.set(name, validateField);\n    return () => {\n      context?.validators.delete(name);\n    };\n  }, [context, name, validateField]);\n\n  useEffect(() => {\n    context?.invalidations.set(name, clearValidity);\n    return () => {\n      context?.invalidations.delete(name);\n    };\n  }, [context, name, clearValidity]);\n  \n  useEffect(() => {\n    context?.reductions.set(name, () => {\n      reset();\n    });\n    return () => {\n      context?.reductions.delete(name);\n    };\n  }, [context, name, reset]);\n\n  useEffect(() => {\n    context?.status.set(name, status);\n    return () => {\n      context?.status.delete(name);\n    };\n  }, [context, status, name]);\n\n  useEffect(() => {\n    const { context } = refs.current;\n    if (refs.current.name !== name) {\n      context?.setItem(refs.current.name, null, { emit: true, remove: true });\n    }\n    refs.current.name = name;\n    reset();\n  }, [reset, name]);\n  \n  useEffect(() => {\n    onStatusChange?.(status);\n  }, [onStatusChange, status]);\n\n  return cloneElement(children, {\n    onChange,\n    value,\n  });\n};\n\nexport { Field };\n\nfunction validate(rules: Rule[], value: any) {\n  return concat(\n    ...rules.map(v => {\n      let obs: Observable<null | string>;\n      if (typeof v === 'function') {\n        const ret = v(value);\n        if (isObservable(ret)) {\n          obs = ret;\n        } else if (ret instanceof Promise) {\n          obs = from(ret);\n        } else {\n          obs = of(ret);\n        }\n      } else {\n        obs = v.required && !value ? of(v.message ?? '') : of(null);\n      }\n      obs = obs.pipe(\n        concatMap(res => res === null ? of(null) : throwError(() => res))\n      );\n      return obs as Observable<null>;\n    }),\n    of(null),\n  ).pipe(takeLast(1));\n}\n\nfunction toFormValue(e: any) {\n  if (e && e.target && Object.hasOwn(e.target, 'value')) {\n    return e.target.value;\n  }\n  return e;\n}\n"})})]}),"\n",(0,r.jsxs)("details",{children:[(0,r.jsx)("summary",{children:"Item.tsx"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"import { cloneElement, CSSProperties, FC, ReactNode, useCallback, useState } from 'react';\nimport { Field, FieldProps } from './Field';\nimport { Status } from './interface';\nimport styled from 'styled-components';\nimport { combineClass } from '@shared/utils';\n\nconst Wrapper = styled.div`\n  &:not(:last-child){\n    margin-bottom: 8px;\n  }\n  .error-tip{\n    margin: 3px 0 0 0;\n    font-size: .8em;\n    color: var(--color-error);\n  }\n`;\n\ninterface FormItemProps extends FieldProps {\n  className?: string;\n  style?: CSSProperties;\n  prefix?: ReactNode;\n}\nconst FormItem: FC<FormItemProps> = (props) => {\n\n  const { onStatusChange, children, className, style, prefix, ...extra } = props;\n\n  const [status, setStatus] = useState<Status>();\n\n  const handleStatusChange = useCallback((status: Status) => {\n    onStatusChange?.(status);\n    setStatus(status);\n  }, [onStatusChange]);\n\n  return (\n    <Wrapper className={className} style={style}>\n      <div className={'form-control'}>\n        { prefix }\n        <Field {...extra} onStatusChange={handleStatusChange}>\n          {\n            cloneElement(children, {\n              className: combineClass(children.props.className, {\n                'status-error': status?.state === 'invalid',\n              }),\n            })\n          }\n        </Field>\n      </div>\n      {\n        typeof status?.message === 'string' ?\n          <p className={'error-tip'}>{ status.message }</p> :\n          null\n      }\n    </Wrapper>\n  );\n};\n\nexport { FormItem };\n"})})]}),"\n",(0,r.jsxs)("details",{children:[(0,r.jsx)("summary",{children:"Context.ts"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"import { createContext } from 'react';\nimport type { Observable } from 'rxjs';\nimport { Status } from './interface';\n\nexport type FormValues = Record<string, any>;\n\nexport type FormValuesMap = Map<string, any>;\n\nexport const FormValuesContext = createContext<FormValuesMap | null>(null);\n\nexport interface FormContextInterface {\n  readonly values: FormValuesMap;\n  setItem: (name: string, value: any, options?: {\n    emit?: boolean;\n    remove?: boolean;\n  }) => void;\n  toJSON: () => FormValues;\n  reductions: Map<string, () => void>;\n  invalidations: Map<string, () => void>;\n  validators: Map<string, () => Observable<Status>>;\n  status: Map<string, Status>;\n}\n\nexport const FormContext = createContext<FormContextInterface | null>(null);\n"})})]}),"\n",(0,r.jsxs)("details",{children:[(0,r.jsx)("summary",{children:"interface.ts"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"import type { Observable } from 'rxjs';\n\nexport interface FormControlled<T> {\n  value?: T;\n  onChange?(e: T): void;\n}\n\ninterface RuleRequired {\n  required?: boolean;\n  message?: string;\n}\ninterface RuleValidator {\n  (value: any): null | string | Promise<null | string> | Observable<null | string>;\n}\nexport type Rule = RuleRequired | RuleValidator;\n\nexport interface Status {\n  state: 'valid' | 'invalid' | 'pending' | 'initial';\n  name: string;\n  message?: string;\n}\n\n"})})]})]})}var F=function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return(0,r.jsx)(y,Object.assign({},e,{children:(0,r.jsx)(C,e)}))}},3121:function(e){"use strict";e.exports=ReactTransitionGroup},9378:function(e){"use strict";e.exports=algoliasearch},7513:function(e){"use strict";e.exports=rxjs}},function(e){e.O(0,[9894,2128,3554,5685,2374,9774,2888,179],function(){return e(e.s=1841)}),_N_E=e.O()}]);